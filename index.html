<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSO通用登录验证</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: Arial, sans-serif; }
        .container { width: 100%; max-width: 600px; margin: 100px auto; padding: 20px; text-align: center; }
        .success { color: #28a745; font-size: 18px; margin: 20px 0; }
        .error { color: #dc3545; font-size: 18px; margin: 20px 0; }
        .loading { color: #007bff; font-size: 16px; }
        a { color: #007bff; text-decoration: none; }
        a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <div class="container" id="app">
        <div class="loading" id="loading">正在检测登录状态...</div>
    </div>

    <script>
        // 基础配置（仅需配置SSO地址，SERVICE_URL自动检测）
        const CONFIG = {
            SSO_LOGIN_URL: 'https://sso.stu.edu.cn/login',       // SSO登录地址（无需修改）
            SSO_VALIDATE_URL: 'https://sso.stu.edu.cn/serviceValidate', // SSO验证地址（无需修改）
            ALLOWED_USERS: ['22ycui']                          // 授权用户列表（按需修改）
        };

        // 核心：自动检测当前页面的完整根地址（协议+域名+端口），作为SERVICE_URL
        // 例：http://localhost:8080、https://test.com:8088 等
        const SERVICE_URL = `${window.location.protocol}//${window.location.host}${window.location.pathname}`;

        // 页面加载完成后执行主逻辑
        document.addEventListener('DOMContentLoaded', async () => {
            const app = document.getElementById('app');
            const loading = document.getElementById('loading');
            
            try {
                // 1. 解析URL中的ticket参数
                const ticket = getUrlParam('ticket');
                
                // 2. 无ticket则跳转SSO登录页（自动拼接当前SERVICE_URL作为回调）
                if (!ticket) {
                    loading.textContent = '未检测到登录凭证，正在跳转SSO登录页...';
                    // 对SERVICE_URL进行URL编码，避免特殊字符导致的回调异常
                    const loginUrl = `${CONFIG.SSO_LOGIN_URL}?service=${encodeURIComponent(SERVICE_URL)}`;
                    window.location.href = loginUrl;
                    return;
                }

                // 3. 有ticket则请求SSO验证接口（携带当前SERVICE_URL）
                loading.textContent = '检测到登录凭证，正在验证...';
                const validateResult = await validateTicket(ticket);
                
                // 4. 验证失败处理
                if (!validateResult.success) {
                    app.innerHTML = `
                        <h3>登录验证失败</h3>
                        <div class="error">错误信息：${validateResult.errorMsg || '未知错误'}</div>
                        <p>请<a href="${CONFIG.SSO_LOGIN_URL}?service=${encodeURIComponent(SERVICE_URL)}">重新登录</a></p>
                    `;
                    return;
                }

                // 5. 验证成功，提取用户名并判断权限
                const username = validateResult.username;
                const hasPermission = CONFIG.ALLOWED_USERS.includes(username);
                
                // 6. 权限判断结果展示
                if (hasPermission) {
                    app.innerHTML = `
                        <h3>登录验证成功</h3>
                        <div class="success">欢迎您，${username}！</div>
                        <div class="success">已获得脚本使用权限</div>
                        
                    `;
                    alert("验证成功，欢迎您 " + username + "！");
                    // 修改状态栏的url显示为SERVICE_URL
                    window.history.replaceState({}, '', SERVICE_URL);
                } else {
                    app.innerHTML = `
                        <h3>权限验证失败</h3>
                        <div class="error">${username}，您暂无权限使用本脚本</div>
                    `;
                    window.history.replaceState({}, '', SERVICE_URL);
                }

            } catch (err) {
                // 全局异常处理
                app.innerHTML = `
                    <h3>操作异常</h3>
                    <div class="error">异常信息：${err.message || '网络错误或服务器异常'}</div>
                    <p>请<a href="${CONFIG.SSO_LOGIN_URL}?service=${encodeURIComponent(SERVICE_URL)}">重新尝试</a></p>
                `;
                console.error('SSO验证异常：', err);
            }
        });

        /**
         * 工具方法：解析URL参数
         * @param {string} name - 要获取的参数名
         * @returns {string|null} 参数值，无则返回null
         */
        function getUrlParam(name) {
            const searchParams = new URLSearchParams(window.location.search);
            return searchParams.get(name);
        }

        /**
         * 核心方法：验证ticket有效性（携带自动检测的SERVICE_URL）
         * @param {string} ticket - 从URL解析的ticket
         * @returns {Promise<object>} 验证结果 {success: boolean, username?: string, errorMsg?: string}
         */
        async function validateTicket(ticket) {
            // 构造验证请求参数（SERVICE_URL为自动检测的当前网址）
            const params = new URLSearchParams({
                service: SERVICE_URL,
                ticket: ticket
            });
            const requestUrl = `${CONFIG.SSO_VALIDATE_URL}?${params.toString()}`;

            try {
                // 发送GET请求（与原Python请求头保持一致）
                const response = await fetch(requestUrl, {
                    method: 'GET',
                    headers: {
                        'Connection': 'close'
                    },
                    mode: 'cors', // 跨域请求模式
                    cache: 'no-cache'
                });

                // 检查HTTP响应状态
                if (!response.ok) {
                    throw new Error(`HTTP请求失败，状态码：${response.status}`);
                }

                // 解析XML响应内容并处理
                const xmlText = await response.text();
                const result = parseSsoXml(xmlText);

                return result;
            } catch (err) {
                console.error('Ticket验证失败：', err);
                return {
                    success: false,
                    errorMsg: err.message
                };
            }
        }

        function parseSsoXml(xmlText) {
            try {
                // 前端XML解析器
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');

                // 检查XML解析错误
                const parseError = xmlDoc.querySelector('parsererror');
                if (parseError) {
                    throw new Error('XML解析失败，返回内容非有效XML');
                }

                // XPath匹配authenticationSuccess节点（忽略命名空间）
                const successXPath = '//*[local-name()="authenticationSuccess"]';
                const successNode = xmlDoc.evaluate(
                    successXPath,
                    xmlDoc,
                    null,
                    XPathResult.FIRST_ORDERED_NODE_TYPE,
                    null
                ).singleNodeValue;
                
                if (successNode) {
                    // 提取用户名
                    const usernameNode = successNode.firstElementChild;
                    const username = usernameNode ? usernameNode.textContent.trim() : '';
                    if (!username) {
                        return { success: false, errorMsg: 'SSO返回无有效用户名' };
                    }
                    return { success: true, username: username };
                }

                // XPath匹配authenticationFailure错误节点
                const failureXPath = '//*[local-name()="authenticationFailure"]';
                const failureNode = xmlDoc.evaluate(
                    failureXPath,
                    xmlDoc,
                    null,
                    XPathResult.FIRST_ORDERED_NODE_TYPE,
                    null
                ).singleNodeValue;
                
                if (failureNode) {
                    const errorMsg = failureNode.textContent.trim() || 'SSO验证失败，原因未知';
                    return { success: false, errorMsg: errorMsg };
                }

                // 无匹配节点，返回格式错误
                return { success: false, errorMsg: 'SSO返回非预期的XML格式' };
            } catch (err) {
                console.error('XML解析异常：', err);
                return {
                    success: false,
                    errorMsg: `解析验证结果失败：${err.message}`
                };
            }
        }
    </script>
</body>
</html>